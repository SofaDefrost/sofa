import pyximport; pyximport.install()
import cythonfield

import math
from math import sqrt

class Sphere(object):
	def __init__(self, position=[0,0,0], radius=0.5):
		self.position = position
		self.radius = radius

	def eval(self, x,y,z):
		x = x - self.position[0]
		y = y - self.position[1]
		z = z - self.position[2]

		return math.sqrt( (x*x + y*y + z*z) ) -self.radius

class Difference(object):
	def __init__(self, a, b):
		self.left = a 
		self.right = b

	def eval(self, x,y,z):
		leftv = self.left.eval(x,y,z)
		rightv = self.right.eval(x,y,z)
		return max(leftv, -rightv) 		

def evalField(x,y,z):
        #f=Difference( Sphere([0.5, 0.5, 0.5], 0.2),
        #			  Sphere([0.3, 0.5, 0.5], 0.2) )
        #f=Sphere([0.5,0.7,0.5], 0.1)#
        #return  max(min(min(min(min(min(min(min(min(min(min(max(abs((0.0*x+1.0*(z-0.5)))-0.5,((1.0*x-0.0*(z-0.5))/0.2)*((1.0*x-0.0*(z-0.5))/0.2)+((0.0*(x-0.0)+1.0*(y-0.0))/0.2)*((0.0*(x-0.0)+1.0*(y-0.0))/0.2)-1),((1.0*x-0.0*(z-0.05))/0.6)*((1.0*x-0.0*(z-0.05))/0.6)+((0.0*(x-0.0)+1.0*(y-0.0))/0.6)*((0.0*(x-0.0)+1.0*(y-0.0))/0.6)+((0.0*x+1.0*(z-0.05))/0.075)*((0.0*x+1.0*(z-0.05))/0.075)-1),((1.0*x-0.0*(z-0.15))/0.6)*((1.0*x-0.0*(z-0.15))/0.6)+((0.0*(x-0.0)+1.0*(y-0.0))/0.6)*((0.0*(x-0.0)+1.0*(y-0.0))/0.6)+((0.0*x+1.0*(z-0.15))/0.075)*((0.0*x+1.0*(z-0.15))/0.075)-1),((1.0*x-0.0*(z-0.25))/0.6)*((1.0*x-0.0*(z-0.25))/0.6)+((0.0*(x-0.0)+1.0*(y-0.0))/0.6)*((0.0*(x-0.0)+1.0*(y-0.0))/0.6)+((0.0*x+1.0*(z-0.25))/0.075)*((0.0*x+1.0*(z-0.25))/0.075)-1),((1.0*x-0.0*(z-0.35))/0.6)*((1.0*x-0.0*(z-0.35))/0.6)+((0.0*(x-0.0)+1.0*(y-0.0))/0.6)*((0.0*(x-0.0)+1.0*(y-0.0))/0.6)+((0.0*x+1.0*(z-0.35))/0.075)*((0.0*x+1.0*(z-0.35))/0.075)-1),((1.0*x-0.0*(z-0.45))/0.6)*((1.0*x-0.0*(z-0.45))/0.6)+((0.0*(x-0.0)+1.0*(y-0.0))/0.6)*((0.0*(x-0.0)+1.0*(y-0.0))/0.6)+((0.0*x+1.0*(z-0.45))/0.075)*((0.0*x+1.0*(z-0.45))/0.075)-1),((1.0*x-0.0*(z-0.55))/0.6)*((1.0*x-0.0*(z-0.55))/0.6)+((0.0*(x-0.0)+1.0*(y-0.0))/0.6)*((0.0*(x-0.0)+1.0*(y-0.0))/0.6)+((0.0*x+1.0*(z-0.55))/0.075)*((0.0*x+1.0*(z-0.55))/0.075)-1),((1.0*x-0.0*(z-0.65))/0.6)*((1.0*x-0.0*(z-0.65))/0.6)+((0.0*(x-0.0)+1.0*(y-0.0))/0.6)*((0.0*(x-0.0)+1.0*(y-0.0))/0.6)+((0.0*x+1.0*(z-0.65))/0.075)*((0.0*x+1.0*(z-0.65))/0.075)-1),((1.0*x-0.0*(z-0.75))/0.6)*((1.0*x-0.0*(z-0.75))/0.6)+((0.0*(x-0.0)+1.0*(y-0.0))/0.6)*((0.0*(x-0.0)+1.0*(y-0.0))/0.6)+((0.0*x+1.0*(z-0.75))/0.075)*((0.0*x+1.0*(z-0.75))/0.075)-1),((1.0*x-0.0*(z-0.85))/0.6)*((1.0*x-0.0*(z-0.85))/0.6)+((0.0*(x-0.0)+1.0*(y-0.0))/0.6)*((0.0*(x-0.0)+1.0*(y-0.0))/0.6)+((0.0*x+1.0*(z-0.85))/0.075)*((0.0*x+1.0*(z-0.85))/0.075)-1),((1.0*x-0.0*(z-0.95))/0.6)*((1.0*x-0.0*(z-0.95))/0.6)+((0.0*(x-0.0)+1.0*(y-0.0))/0.6)*((0.0*(x-0.0)+1.0*(y-0.0))/0.6)+((0.0*x+1.0*(z-0.95))/0.075)*((0.0*x+1.0*(z-0.95))/0.075)-1),-min(min(min(min(min(min(min(min(min(min(max(abs((0.0*x+1.0*(z-0.5)))-0.49,((1.0*x-0.0*(z-0.5))/0.19)*((1.0*x-0.0*(z-0.5))/0.19)+((0.0*(x-0.0)+1.0*(y-0.0))/0.19)*((0.0*(x-0.0)+1.0*(y-0.0))/0.19)-1),((1.0*x-0.0*(z-0.05))/0.59)*((1.0*x-0.0*(z-0.05))/0.59)+((0.0*(x-0.0)+1.0*(y-0.0))/0.59)*((0.0*(x-0.0)+1.0*(y-0.0))/0.59)+((0.0*x+1.0*(z-0.05))/0.065)*((0.0*x+1.0*(z-0.05))/0.065)-1),((1.0*x-0.0*(z-0.15))/0.59)*((1.0*x-0.0*(z-0.15))/0.59)+((0.0*(x-0.0)+1.0*(y-0.0))/0.59)*((0.0*(x-0.0)+1.0*(y-0.0))/0.59)+((0.0*x+1.0*(z-0.15))/0.065)*((0.0*x+1.0*(z-0.15))/0.065)-1),((1.0*x-0.0*(z-0.25))/0.59)*((1.0*x-0.0*(z-0.25))/0.59)+((0.0*(x-0.0)+1.0*(y-0.0))/0.59)*((0.0*(x-0.0)+1.0*(y-0.0))/0.59)+((0.0*x+1.0*(z-0.25))/0.065)*((0.0*x+1.0*(z-0.25))/0.065)-1),((1.0*x-0.0*(z-0.35))/0.59)*((1.0*x-0.0*(z-0.35))/0.59)+((0.0*(x-0.0)+1.0*(y-0.0))/0.59)*((0.0*(x-0.0)+1.0*(y-0.0))/0.59)+((0.0*x+1.0*(z-0.35))/0.065)*((0.0*x+1.0*(z-0.35))/0.065)-1),((1.0*x-0.0*(z-0.45))/0.59)*((1.0*x-0.0*(z-0.45))/0.59)+((0.0*(x-0.0)+1.0*(y-0.0))/0.59)*((0.0*(x-0.0)+1.0*(y-0.0))/0.59)+((0.0*x+1.0*(z-0.45))/0.065)*((0.0*x+1.0*(z-0.45))/0.065)-1),((1.0*x-0.0*(z-0.55))/0.59)*((1.0*x-0.0*(z-0.55))/0.59)+((0.0*(x-0.0)+1.0*(y-0.0))/0.59)*((0.0*(x-0.0)+1.0*(y-0.0))/0.59)+((0.0*x+1.0*(z-0.55))/0.065)*((0.0*x+1.0*(z-0.55))/0.065)-1),((1.0*x-0.0*(z-0.65))/0.59)*((1.0*x-0.0*(z-0.65))/0.59)+((0.0*(x-0.0)+1.0*(y-0.0))/0.59)*((0.0*(x-0.0)+1.0*(y-0.0))/0.59)+((0.0*x+1.0*(z-0.65))/0.065)*((0.0*x+1.0*(z-0.65))/0.065)-1),((1.0*x-0.0*(z-0.75))/0.59)*((1.0*x-0.0*(z-0.75))/0.59)+((0.0*(x-0.0)+1.0*(y-0.0))/0.59)*((0.0*(x-0.0)+1.0*(y-0.0))/0.59)+((0.0*x+1.0*(z-0.75))/0.065)*((0.0*x+1.0*(z-0.75))/0.065)-1),((1.0*x-0.0*(z-0.85))/0.59)*((1.0*x-0.0*(z-0.85))/0.59)+((0.0*(x-0.0)+1.0*(y-0.0))/0.59)*((0.0*(x-0.0)+1.0*(y-0.0))/0.59)+((0.0*x+1.0*(z-0.85))/0.065)*((0.0*x+1.0*(z-0.85))/0.065)-1),((1.0*x-0.0*(z-0.95))/0.59)*((1.0*x-0.0*(z-0.95))/0.59)+((0.0*(x-0.0)+1.0*(y-0.0))/0.59)*((0.0*(x-0.0)+1.0*(y-0.0))/0.59)+((0.0*x+1.0*(z-0.95))/0.065)*((0.0*x+1.0*(z-0.95))/0.065)-1))
        return cythonfield.evalField(x,y,z)

def evalComplexField(x,y,z):
        p=primitives.Point(x,y,z)
        niceaccordion=accordion.accordionUniform(1.0,0.2,0.01, "ellipsoid",5,0.6,0.6,0.5)


        listheigthsJoiningPoints=[0.3,0.7,0.9]
        listAxesX=[0.5,0.5,0.5,0.5]
        listAxesY=[0.5,0.5,0.5,0.5]
        Zrecovering=0.1
        listcavities=[[0.25,"frisbee",0.5,0.5,0.2],[0.75,"frisbee",0.5,0.5,0.2],[0.5,"frisbee",0.5,0.5,0.2]]
#        niceaccordion=accordion.accordionFreeDimension(1.0,0.2,0.01, listcavities)
#        niceaccordion=accordion.accordionRecoveringGiven(1.0,0.2,0.01,"frisbee",listheigthsJoiningPoints, listAxesX, listAxesY,Zrecovering)
        return niceaccordion.eval(p)
