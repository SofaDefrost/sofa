
            }

            vec4 map( in vec3 pos )
            {
                return vec4(ThomasFunc(pos), vec3(1.0, 0.0, 0.0));
            }

            vec4 castRay( in vec3 ro, in vec3 rd )
            {
                float depth = MIN_DIST;
                vec3 m = vec3(-1.0, -1.0, -1.0);
                for( int i = 0; i < MAX_MARCHING_STEPS; i++ )
                {
                    vec4 res = map( ro+rd*depth );
                    if( res.x < EPSILON || depth > MAX_DIST ) break;
                    depth += res.x*0.2;
                    m = res.yzw;
                }
                return vec4( depth, m );
            }

            float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
            {
                float res = 1.0;
                float t = mint;
                for( int i=0; i<16; i++ )
                {
                    float h = map( ro + rd*t ).x;
                    res = min( res, 8.0*h/t );
                    t += clamp( h, 0.02, 0.10 );
                    if( h<0.001 || t>tmax ) break;
                }
                return clamp( res, 0.0, 1.0 );
            }

            vec3 estimateNormal(vec3 p) {
                return normalize(vec3(
                map(vec3(p.x + EPSILON, p.y, p.z)).x - map(vec3(p.x - EPSILON, p.y, p.z)).x,
                map(vec3(p.x, p.y + EPSILON, p.z)).x - map(vec3(p.x, p.y - EPSILON, p.z)).x,
                map(vec3(p.x, p.y, p.z  + EPSILON)).x - map(vec3(p.x, p.y, p.z - EPSILON)).x
                ));
            }

            vec3 render( in vec3 ro, in vec3 rd )
            {
                vec4 res = castRay(ro,rd);
                if (res.x > MAX_DIST) return vec3(1.0, 1.0, 1.0)
                ;
                float dist = res.x;
                vec3 col = res.yzw;
                vec3 pos = ro + dist * rd;
                vec3 nor = estimateNormal( pos );
                vec3 ref = reflect( rd, nor );

                vec3  lig = normalize(ro);
                float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );
                float dif = clamp( dot( nor, lig ), 0.0, 1.0 );
                float dom = smoothstep( -0.1, 0.1, ref.y );
                float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);
                dif *= softshadow( pos, lig, 0.02, 2.5 );
                dom *= softshadow( pos, ref, 0.02, 2.5 );

                vec3 lin = vec3(0.0);
                lin += 1.30*dif*vec3(1.00,0.80,0.55);
                lin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;
                lin += 0.40*amb*vec3(0.40,0.60,1.00);
                lin += 0.50*dom*vec3(0.40,0.60,1.00);
                col = col*lin;

                return vec3( clamp(col,0.0,1.0) );
            }

            vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {
                vec2 xy = fragCoord - size / 2.0;
                float z = size.y / tan(radians(fieldOfView));
                return normalize(vec3(xy, -z));
            }

            mat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {
                vec3 f = normalize(center - eye);
                vec3 s = normalize(cross(f, up));
                vec3 u = cross(s, f);
                return mat3(s, u, -f);
            }

            void main()
            {
		vec2 mo = vec2(mouse.x/resolution.x, mouse.y/resolution.y);
                vec3 viewDir = rayDirection(45.0, resolution.xy, gl_FragCoord.xy);
                vec3 camPosition = vec3( mouse.z*3.5*cos( 6.0*mo.x), 2.0*mo.y, mouse.z*4.0*sin(6.0*mo.x) );
                mat3 viewToWorld = viewMatrix(camPosition, vec3(0.0), vec3(0.0, 1.0, 0.0));
                vec3 worldDir = viewToWorld * viewDir;
                gl_FragColor = vec4( render( camPosition, worldDir ), 1.0 );

            }
